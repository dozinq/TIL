## 큐(Queue)

---

- **큐** : 스택과 마찬가지로 삽입과 삭제의 위치가 제한적인 자료구조, 큐의 뒤에서는 삽입만 하고, 큐의 앞에서는 삭제만 이루어지는 구조이다.
  - FIFO (: First In First Out) : 큐에 삽입한 순서대로 원소가 저장되어, 가장 먼저 삽입된 원소는 가장 먼저 삭제된다.

> -연산
>
> enQueue(item) : 큐의 뒤쪽(rear 다음)에 원소를 삽입하는 연산
>
> deQueue() : 큐의 앞쪽(front)에서 원소를 삭제하고 반환하는 연산
>
> createQueue() : 공백 상태의 큐를 생성하는 연산
>
> isEmpty() : 큐가 공백상태인지를 확인하는 연산
>
> isFull() : 큐가 포화상태인지를 확인하는 연산
>
> Qpeek() : 큐의 앞쪽(front)에서 원소를 삭제 없이 반환하는 연산

<br>

---

- **선형큐** : 1차원 배열을 이용한 큐

  - 큐의 크기 = 배열의 크기
  - front : 저장된 첫 번째 원소의 인덱스
  - rear : 저장된 마지막 원소의 인덱스

  - 상태 표현
    - 초기 상태 : front = rear = -1
    - 공백 상태 : front == rear
    - 포화 상태 : rear == n-1 (n : 배열의 크기, n-1 : 배열의 마지막 인덱스)
  - 초기 공백 큐 생성
    - 크기 n인 1차원 배열 생성
    - front와 rear를 -1로 초기화

  ```python
  front = -1
  rear = -1
  Q = [0]*10
  rear += 1		# enqueue(1)
  Q[rear] = 1
  rear += 1		# enqueue(2)
  Q[rear] = 2
  
  front += 1
  print(Q[front])	# 1
  front += 1
  print(Q[front])	# 2
  ```

<br>

---

- **원형 큐**

  - 초기 공백 상태 : front = rear = 0

  - Index의 순환

    - front와 rear의 위치가 배열의 마지막 인덱스인 n-1을 가리킨 후, 그 다음에는 논리적 순환을 이루어 배열의 처음 인덱스인 0으로 이동해야 함
    - 이를 위해 나머지 연산자 mod를 사용함

  - front 변수

    - 공백 상태와 포화 상태 구분을 쉽게 하기 위해 front가 있는 자리는 사용하지 않고 항상 빈자리로 둠

    |         |        삽입 위치        |         삭제 위치         |
    | :-----: | :---------------------: | :-----------------------: |
    | 선형 큐 |     rear = rear + 1     |     front = front + 1     |
    | 원형 큐 | rear = (rear + 1) mod n | front = (front + 1) mod n |

<br>

---

- **우선순위 큐(Priority Queue)**
  - 우선순위 큐의 특성
    - 우선순위를 가진 항목들을 저장하는 큐
    - FIFO 순서가 아니라 우선순위가 높은 순서대로 먼저 나가게 된다.
  - 우선순위 큐의 구현
    - 배열을 이용한 우선순위 큐
      - 배열을 이용하여 자료 저장
      - 원소를 삽입하는 과정에서 우선순위를 비교하여 적절한 위치에 삽입하는 구조
      - 가장 앞에 최고 우선순위의 원소가 위치하게 됨
      - 배열을 사용하므로, 삽입이나 삭제 연산이 일어날 때 원소의 재배치가 발생함
      - 이에 소요되는 시간이나 메모리 낭비가 큼
    - 리스트를 이용한 우선순위 큐

<br>

---

- **큐의 활용 : 버퍼(Buffer)**
  - 버퍼 : 데이터를 한 곳에서 다른 한 곳으로 전송하는 동안 일시적으로 그 데이터를 보관하는 메모리의 영역
  - 버퍼링 : 버퍼를 활용하는 방식 또는 버퍼를 채우는 동작을 의미한다.
  - 버퍼는 일반적으로 입출력 및 네트워크와 관련된 기능에서 이용된다.
  - 순서대로 입력/출력/전달되어야 하므로 FIFO 방식의 자료구조인 큐가 활용된다.

<br>

---

- **BFS (Breadth First Search, 너비 우선 탐색)** : 탐색 시작점의 인접한 정점들을 먼저 모두 차례로 방문한 후에, 방문했던 정점을 시작점으로 하여 다시 인접한 정점들을 차례로 방문하는 방식

  - 인접한 정점들에 대해 탐색을 한 후, 차례로 다시 너비우선탐색을 진행해야 하므로, 선입선출 형태의 자료구조인 큐를 활용함

  - 입력 파라미터 : 그래프 G와 탐색 시작점 v

    ```python
    def BFS(G, v) :					# 그래프 G, 탐색 시작점 v
        visited = [0]*(n+1)			# n : 정점의 개수
        queue = []					# 큐 생성
        queue.append(v)				# 시작점 v를 큐에 삽입
        while queue:				# 큐가 비어있지 않은 경우
            t = queue.pop(0)		# 큐의 첫번째 원소 반환
            if not visited[t]:		# 방문되지 않은 곳이라면
                visited[t] = True	# 방문한 것으로 표시
                visit(t)			# 정점 t에서 할 일
            for i in G[t]:			# t와 연결된 모든 정점에 대해
                if not visited[i]:	# 방문되지 않은 곳이라면
                    queue.append(i)	# 큐에 넣기
    ```