# SQLD 1과목

## 제 1장 데이터 모델링의 이해

#### 1. 데이터 모델의 이해

1. 모델링
   - 다양한 현상을 추상화, 단순화하여 일정한 표기법에 의해 표현하는 것
   - 모델이란 현실 세계의 추상화 된 반영

2. 모델링 특징 (추단명)
   - 추상화 : 일정한 형식에 맞춰서 표현
   - 단순화 : 제한된 표기법이나 언어로 표현
   - 명확화 : 애매모호함을 제거하여 이해가 쉽게 표현
3. 모델링의 관점
   - 데이터 관점 : 업무와 데이터 및 데이터 사이의 관계를 모델링
   - 프로세스 관점 : 업무가 실제로 하고있는 일, 해야 하는 일 모델링
   - 데이터와 프로세스의 상관 관점 : 데이터에 대한 업무 처리 방식의 영향을 모델링

- 데이터 모델링의 중요성과 유의점
  1) 중요성 : 파급효과, 간결한 표현, 데이터 품질 유지
  2) 유의점
     1) 중복 : 여러 장소에 같은 정보 저장 X
     2) 비유연성 : 데이터의 정의를 데이터 사용 프로세스와 분리
     3) 비일관성 : 모델링할 때 데이터 간 상호 연관 관계 명확히 정의

4. 데이터 모델링의 3단계
   - 개념적 모델링(계획/분석) : ERD 도출, 업무중심, 포괄적인 수준의 모델링
   - 논리적 모델링(분석) : 테이블 도출, key/속성/관계를 표현, 재사용성, 정규화 수행
   - 물리적 모델링(설계) : DB 구축, 물리적 성격, 개념적보다 구체적
5. 데이터 독립성
   - 데이터의 구조가 변경되어도 응용 프로그램이 변경될 필요가 없음
   - **논리적 독립성 + 물리적 독립성**으로 실현됨
   - 필요성 : 데이터 중복성과 복잡도가 증가 -> 요구사항 대응 저하, 유지보수 비용 증가

- 데이터베이스 스키마

  - 데이터 모델링 대상(틀)
  - 데이터베이스 구조, 데이터 타입, 제약조건에 대한 명세
  - 데이터베이스 설계 단계에서 명시되며 자주 변경되지 않음

- 데이터베이스의 3단계 구조

  - 외부 스키마 : 응용프로그램 관점에서의 요구사항, 사용자 관점, DB 정의

  - 개념 스키마 : 외부 스키마가 필요로 하는 데이터를 모두 모아놓은 것. 설계자 관점

    (**DB에 저장되는 데이터와 사용자 관계 표현 -> 모든 사용자 관점 통합, 조직 전체 통합**)

  - 내부 스키마 : 데이터베이스가 물리적으로 저장된 형식, 개발자 관점

  -> 데이터 모델링은 통합 관점의 개념 스키마를 만들어 가는 과정

- 사상(Mapping)
  - 상호 독립적인 개념을 연결시켜주는 다리
  - 논리적 사상 : 외부화면 및 사용자 인터페이스 스키마 구조는 개념 스키마와 연결
  - 물리적 사상 : 개념 스키마 구조와 물리적 저장된 구조(테이블 스페이스)와 연결
- 논리적 독립성
  - 논리적 사상(외부적-개념적)을 통해 논리적 독립성 보장
  - 개념 스키마가 변경되어도 외부 스키마에는 영향 X
  - 논리적 구조가 변경되어도 응용 프로그램에는 영향 X, 통합 구조 변경 가능
- 물리적 독립성
  - 물리적 사상 (개념적-내부적)을 통해 물리적 독립성 보장
  - 내부 스키마가 변경되어도 외부/개념 스키마 영향 X
  - 응용프로그램과 개념 스키마에 영향 없이 저장장치 구조변경 가능, 물리적 구조

6. 데이터 모델링 3요소 (개체, 속성, 관계)
   - 업무가 관여하는 **개체** : 엔터티 타입, 엔터티 / 엔터티, 인스턴스, 어커런스
   - 개체가 가지는 **속성** : 속성 / 속성값
   - 개체가 가지는 **관계** : 관계 / 페어링
7. ERD (Entity Relationship Diagram)
   - 데이터 모델 표기법 : 엔터티를 사각형, 관계를 마름모, 속성을 타원형으로 표현
8. ERD 표기법을 이용하여 모델링 하는 방법
   1. 엔터티를 그린 후 적절하게 배치
   2. 엔터티 간 관계 설정
      - 식별자 관계(부모로부터 상속받은 FK가 자식의 PK의 일부가 되는 관계)를 우선 설정함
      - 가급적 Cycle 관계도 발생하지 않아야 한다.
   3. 관계명 기술 (양 방향)
      - 현재형 사용, 지나치게 포괄적인 단어는 지양
   4. 관계차수, 관계의 참여도, 선택성 표시
9. 좋은 모델링의 조건
   - 완전성 : 업무에서 필요로 하는 모든 데이터가 데이터 모델에 정의되어야 한다.
   - 중복배제 : 동일한 사실은 반드시 한번만 기록
   - 업무규칙 : 업무규칙이 데이터 모델에 표현되어야 한다
   - 데이터 재사용 : 회사 전체 관점에서 공통 데이터 도출, 전 영역 사용할 수 있도록 설계
   - 통합성 : 동일한 데이터는 조직의 전체에서 한 번만 정의되고 이를 참조/활용



#### 2. 엔터티

1. 엔터티
   - 업무에 필요한 정보를 저장하고 관리하기 위한 집합적인 것 (실체, 객체)
   - **엔터티는 인스턴스의 집합**
2. 엔터티의 분류

- 유무형에 따른 분류
  1. 유형 엔터티 : 물리적인 형태가 있고 안정적이며 지속적 활용 ex) 교수, 강의실, 학생
  2. 개념 엔터티 : 물리적인 형태는 존재하지 않으나 관리해야 할 개념적 정보 ex) 수업, 보험상품
  3. 사건 엔터티 : 업무 수행 과정에서 발생, 비교적 발생량 많음 ex) 수강신청, 주문
- 발생시점에 따른 분류
  1. 기본 엔터티 : 독립적으로 생성되는 엔터티
  2. 중심 엔터티 : 기본 엔터티와 행위 엔터티 중간에 존재하는 엔터티
  3. 행위 엔터티 : 2개 이상의 부모 엔터티로부터 발생, 비즈니스 프로세스를 실행하면서 생성되는 엔터티, 지속적 정보가 추가되고 변경되어 데이터양이 가장 많음

3. 엔터티의 특징
   - 업무에서 필요로 하는 정보 포함
   - 유일한 식별자를 가짐
   - 2개 이상의 인스턴스를 포함함
   - 업무 프로세스에 이용됨
   - 속성 없이 엔터티의 이름만 존재할 수 없음
   - 다른 엔터티와 최소 1개 이상의 관계가 존재
4. 엔터티의 명명
   - 엔터티 생성 의미대로, 실제 업무에서 사용하는 용어를 사용
   - 약어 사용 X, 단수명사 사용
   - 이름이 동일한 엔터티가 중복으로 존재 X



#### 3. 속성

1. 속성의 정의
   - 사물의 특징 또는 본질적인 성질
   - 인스턴스에 대해 의미상 더이상 분리되지 않는 **최소의 데이터 단위**
   - 엔터티에 속한 인스턴스들의 성격을 구체적으로 나타냄
   - 엔터티, 인스턴스, 속성, 속성값의 대응

- 엔터티, 인스턴스 속성의 관계
  - 1개의 엔터티 : 2개 이상의 인스턴스 집합을 가짐
  - 1개의 인스턴스 : 2개 이상의 속성을 가짐
  - 1개의 속성 : 1개의 속성값을 가짐

2. 속성의 특징
   - 해당 업무에서 필요하고 관리해야 하는 정보
   - 모든 속성은 정해진 주식별자에 함수적으로 종속되어야 함
   - 하나의 속성은 한 개의 값만을 가짐
3. 속성의 명명
   - 현업에서 사용하는 이름을 부여
   - 약어 사용은 가급적 X
   - 수식어/소유격 X, 서술식 속성명 X, 명사형 속성명 O
   - 전체 데이터 모델에서 유일성 확보
4. 속성의 도메인
   - 각 속성이 가질 수 있는 값의 범위 ex) 학점 : 0.0~4.5 사이의 실수
   - 엔터티 내에서 속성에 대한 데이터타입과 크기, 제약사항을 지정
5. 속성의 분류
   1. 특성에 따른 분류
      - 기본 속성 : 가장 일반적인 속성으로, 원래의 업무로부터 유래된 속성
      - 설계 속성 : 데이터 모델링을 위해 새로 만든 속성(코드, 일련번호)
      - 파생 속성 : 다른 속성들로부터 유도된 속성(통계, 계산된 값)
   2. 분해 가능 여부에 따른 분류
      - 단일 속성 : 하나의 의미
      - 복합 속성 : 여러 의미, 단일 속성으로 분해 가능
      - 단일값 속성 : 속성 한 개의 값
      - 다중값 속성 : 속성 한 개에 여러 값, 엔터티로 분해 가능
   3. 엔터티 구성 방식에 따른 분류
      - 기본키 속성(PK) : 엔터티의 인스턴스를 구별할 수 있는 속성
      - 외래키 속성(FK) : 타 엔터티의 PK를 참조하는 속성
      - 일반 속성 : 엔터티에 포함되고 PK나 FK 속성이 아닌 속성



#### 4. 관계

1. 관계와 페어링
   - 관계 : 엔터티의 인스턴스 사이의 논리적인 연관성으로써, 존재의 형태로서나 행위 서로에게 연관성이 부여된 상태
   - 페어링 : 엔터티 내 인스턴스간 개별적 관계 -> 이것의 집합을 관계로 표현
   - 인스턴스의 집합 -> 엔터티 페어링의 집합 -> 관계
2. 관계의 분류
   1. ERD : 존재에 의한 관계 / 행위에 의한 관계 (구분 없이 단일화된 표기법 사용)
   2. UML(Unified Modeling Language) : 연관 관계 / 의존 관계 (실선과 점선 표기법으로 구분)
3. 관계의 표기법
   1. 관계명 : 엔터티가 관계에 참여하는 형태, 각 관계는 2개의 관계명 및 관점을 가짐
   2. 관계차수 : 1:1, 1:M, M:M (관계 엔터티 이용)
   3. 관계 선택사양 : 필수참여, 선택참여



#### 5. 식별자

1. 식별자의 개념
   - 하나의 엔터티에 구성되어있는 여러 개 속성 중 엔터티를 대표할 수 있는 속성을 의미
   - 하나의 엔터티는 반드시 하나의 유일한 식별자가 존재
2. 식별자의 분류
   - 대표성
     - 주식별자 : 엔터티 내에서 각 인스턴스를 구분 가능, 타 엔터티와 참조관계를 연결 가능
     - 보조식별자 : 엔터티 내에서 각 인스턴스를 구분 가능, 대표성을 갖지 못해 참조관계 연결에 사용되지 않음
   - 목적
     - 내부식별자 : 자연스럽게 존재하는 식별자
     - 외부식별자 : 관계를 통해 유입되는 타 엔터티의 식별자, 주식별자 속성 또는 일반 속성으로 포함될 수 있음
   - 속성 수
     - 단일식별자 : 하나의 속성으로 구성된 식별자
     - 복합식별자 : 둘 이상의 속성으로 구성된 식별자
   - 본질
     - 본질식별자 : 업무에 의해 만들어지는 식별자
     - 인조식별자 : 원조식별자가 복잡한 구성을 가지고 있기 때문에 인위적으로 만든 식별자
3. 식별자의 특징(**유최불존**)
   - 유일성 : 주식별자에 의해 엔터티 내의 모든 인스턴스들을 유일하게 구분함
   - 최소성 : 주식별자를 구성하는 속성의 수는 유일성을 만족하는 최소의 수가 되어야 함
   - 불변성 : 주식별자가 지정되면 그 식별자의 값은 변하지 않아야 함
   - 존재성 : 주식별자가 지정되면 반드시 데이터 값이 존재해야 함
4. 주식별자 도출 기준
   - 유일성을 갖는 속성 중 해당 업무에서 자주 이용되는 속성을 지정
   - 명칭, 내역 등과 같이 이름으로 기술되는 것들은 가능하면 주식별자로 지정하지 X
   - 복합식별자를 구성할 경우 너무 많은 속성이 포함되지 않아야 함
5. 식별자 관계와 비식별자 관계
   1. 식별자 관계(실선)
      - 자식이 부모의 기본키를 상속받아 기본키로 사용하는 경우
      - 강한 연결관계, 부모에 종속, Null X, 1:1 or 1:N 관계
      - 문제점 : 자식의 주식별자 속성이 지속적으로 증가할 수 있음 -> 복잡, 오류가능성
   2. 비식별자 관계(점선)
      - 부모로부터 속성을 받아 일반 속성으로 사용하는 경우 (약한 종속)
      - 문제점 : 부모까지 조인, 불필요 현상 발생 -> SQL 구문 길어져 성능 저하



## 제 2장 데이터 모델과 성능

#### 1. 성능 데이터 모델링의 개요

1. 성능 데이터 모델링 정의
   - 데이터베이스 성능을 고려하여 데이터 모델링을 수행하는 것
   - 정규화, 반정규화, 테이블 통합 및 분할, 조인 구조, PK/FK 설정 등
2. 수행 시점
   - 빠를수록 좋음
   - 분석/설계 단계에서 성능 모델링 수행 best -> 재업무 비용 최소화
3. 성능 데이터 모델링 고려사항
   - 정규화를 정확하게 수행 : 주요 관심사별로 테이블을 분산시킴
   - 데이터베이스 용량산정 수행 : 각 엔터티에 어느 정도의 트랜잭션이 들어오는지 파악
   - 데이터베이스에 발생되는 트랜잭션의 유형 파악 : CRUD 매트릭스 활용
   - 용량과 트랜잭션의 유형에 따라 반정규화 수행 : 테이블, 속성, 관계 변경
   - 이력모델의 조정, 인덱스를 고려한 PK/FK의 순서 조정, 슈퍼/서브타입 조정 등 수행
   - 성능관점에서 데이터 모델 검증



#### 2. 정규화와 성능

1. 정규화(Normalization)
   - 정의 : 데이터 분해 과정, 이상현상 제거
   - 목적 : 삽입/삭제/갱신 이상현상 방지
   - **함수적 종속성에 기반한 정규화 수행 필요**
2. **함수적 종속성(FD, Functional Dependency)**
   - 데이터들이 어떤 기준값에 의해 종속되는 현상을 지칭, 결정자와 종속자의 관계, 결정자의 값으로 종속자의 값을 알 수 있음
   - 결정자 ex) 학번, 주민등록번호
   - 종속자 ex) 이름, 혈액형, 출생지, 주소
3. 종류
   - 정규형 (NF : Normal Form) : 정규화로 도출된 데이터 모델이 갖춰야 할 특성
     1. 1NF (1 Normal Form) : 모든 값이 원자 값을 가짐
     2. 2NF : 부분함수종속 제거
     3. 3NF : 이행함수종속 제거 (식별자가 아닌 속성(주식별자의 일부 or 일반속성)이 결정자 역할하는 함수 종속 제거)
4. 정규화의 효과
   - 성능 = 조회, 입력/수정/삭제 2가지로 분류
   - 데이터 중복 감소 -> 성능 향상
   - 데이터가 관심사별로 묶임 -> 성능 향상
   - 조회 질의에서 조인이 많이 발생 -> 성능 저하
     - 입력 /수정/삭제의 경우 성능 향상
     - 조회의 경우 처리조건에 따라 향상 or 저하



#### 3. 반정규화와 성능

1. 반정규화 (= 역정규화, Denormalization)
   - 정규화된 엔터티, 속성, 관계에 대해 성능 향상을 목적으로 중복, 통합, 분리를 수행하는 데이터 모델링 기법 (cf. 비정규화 : 정규화를 수행하지 않음)
2. 특징
   - 테이블, 칼럼, 관계의 반정규화를 종합적으로 고려 (일반적으로 속성(칼럼)의 중복 시도)
   - 과도한 반정규화는 데이터 무결성을 침해
3. 반정규화 사전절차
   1. 반정규화 대상 조사 : 데이터 처리 범위 및 통계성 등 조사
   2. 다른 방법 검토 : 뷰, 클러스터링, 인덱스, 애플리케이션
   3. 반정규화 적용 : 정규화 수행 후 반정규화 수행
4. 반정규화 기법
   1. 테이블 반정규화
      - 테이블 병합 : 관계 병합, 슈퍼/서브타입 병합 (one to one, plus, single type)
      - 테이블 분할 : 수직, 수평 분할
      - 테이블 추가 : 중복 테이블 / 통계 테이블 / 이력 테이블 / 부분 테이블 추가
   2. 칼럼 반정규화
      - 중복칼럼 추가 : 조인 횟수를 감소시키기 위해 다른 테이블의 칼럼 중복 칼럼 저장
      - 파생칼럼 추가 : 값의 계산으로 인한 성능 저하 예방, 예상값을 미리 계산해서 중복 칼럼 저장 (Derived 칼럼)
      - 이력테이블 칼럼 추가 : 기능성 칼럼, 대량 이력 데이터 처리의 성능 향상을 위해 종료 여부, 최근값 여부 등의 칼럼 추가로 저장
      - PK의 의미적 분리를 위한 칼럼 추가 : PK가 복합 의미를 갖는 경우 단일 속성을 구성시 발생, 구성 요소 값의 조회 성능 향상을 위해 일반 속성을 추가
      - 데이터 복구를 위한 칼럼 추가 : 사용자의 실수 또는 응용프로그램 오류로 인해 데이터가 잘못 처리된 경우 원래 값으로 복구 위해 이전 데이터를 임시로 중복 저장
   3. 관계 반정규화
      - 중복관계 추가 : 조인으로 정보 조회가 가능, 조인 경로 단축을 위해 중복관계 추가
      - 테이블과 칼럼의 반정규화는 데이터 무결성에 영향을 미침
      - 관계의 반정규화는 데이터 무결성 보장 가능, 데이터처리 성능 향상



#### 4. 대량 데이터에 따른 성능

1. 성능 저하 원인
   - 하나의 테이블에 데이터 대량집중 : 테이블 구조 너무 커져 효율성 저하, 디스크 입출력 향상
   - 하나의 테이블에 여러개의 컬럼 존재 : 디스크 점유량 향상, 데이터 읽는 입출력양 증가
   - 대량의 데이터가 처리되는 테이블 : SQL 문장에서 데이터 처리 위한 입출력양 증가, 인덱스 구성
   - 대량의 데이터가 하나의 테이블에 존재 : 인덱스의 크기 증가, 성능 저하
   - 컬럼이 많아지는 경우 : 로우 체이닝, 로우 마이그레이션 발생
2. 해결 방안
   - 한 테이블에 많은 칼럼 -> 수직분할
   - 대량 데이터 저장 문제 -> 파티셔닝, PK에 의한 테이블을 분할

- 대량 데이터 발생에 따른 테이블 분할
  - 수직분할 : 컬럼 단위로 분할하여 입출력 경감
  - 수평분할 : 로우 단위로 분할하여 입출력 경감

3. 대량 데이터 발생으로 인한 현상

   - 블록 : 테이블의 데이터 저장 단위

   - 블록 입출력 횟수 증가, 디스크 입출력 가능성 상승, 디스크 입출력 성능 저하

   - 로우 체이닝(Row Chaining) : 행(Row) 길이가 길어 데이터 블록 하나에 데이터를 모두 저장하지 않고 두 개 이상의 블록에 걸쳐 하나의 행을 저장하는 형태
   - 로우 마이그레이션(Row Migration) : 수정된 데이터가 해당 블록에 저장하지 못하고 다른 블록의 빈 공간에 저장되는 현상

4. 파티셔닝 (Partitioning)

   - 테이블 수평 분할 기법, 논리적으로는 하나의 테이블이지만 물리적으로 여러 데이터 파일에 분산 저장, 데이터 조회 범위를 줄여 성능 향상
   - Range Partition : 범위로 분할  (고객번호 1~1000, 1001~2000 등)
   - List Partition : 특정한 값을 기준으로 분할 (지역 : 서울, 부산 등)
   - Hash Partition : 해시 함수(임의 길이의 데이터를 짧은 길이의 데이터로 매핑하는 함수)를 적용하여 분할, 데이터 위치 알 수 없음
   - Composite Partition : 여러 파티션 기법을 복합적으로 사용하여 분할



#### 5. 데이터베이스 구조와 성능

1. 슈퍼/서브타입 데이터 모델

   - 논리적 데이터 모델에서 주로 이용(분석단계에서 많이 쓰임)
   - 물리적 데이터 모델로 설계 시 문제 발생 (적당한 노하우 X -> 1:1 또는 All in one 타입이 되어버려 성능 저하)
   - 슈퍼타입 : 공통부분을 슈퍼타입으로 모델링
   - 서브타입 : 공통으로부터 상속받아 다른 엔터티와 차이가 있는 속성만 모델링

2. 데이터베이스 성능 저하 원인 3가지

   1. Union 연산에 의해 성능 저하
      - 트랜잭션 : 전체를 일괄 처리, 테이블 : 개별로 유지

   2. 조인에 의해 성능 저하
      - 트랜잭션 : 슈퍼 + 서브타입 공통 처리, 테이블 : 개별로 유지
   3. 불필요하게 많은 데이터 집적
      - 트랜잭션 : 서브타입만 개별로 처리, 테이블 : 하나로 통합

3. 슈퍼/서브타입 데이터 모델 변환을 통한 성능 향상

   - 변환 기준 : 데이터 양, 트랜잭션 유형
   - 데이터 소량 : 데이터 처리 유연성 고려하여 가급적 1:1 관계 유지
   - 데이터 대량 : 3가지 변환 방법 (개별 테이블, 슈퍼 + 서브타입 테이블, 하나의 테이블)

   1. 1:1 타입 : 개별로 처리하는 트랜잭션에 대해 개별 테이블 구성하여 1:1 관계 가짐
   2. 슈퍼/서브 타입 : 슈퍼 + 서브 공통으로 처리하는 트랜잭션에 대해 슈퍼/서브 각각 테이블 구성
   3. All in One 타입 : 전체를 하나로 묶어 트랜잭션이 발생, 단일 테이블 구성

   -> 쪼개질수록 확장성 증가 / DISK, I/O 성능 증가 / 조인 성능 저하 / 관리 용이성 저하

4.  PK/FK 칼럼 순서 및 성능

   - PK/FK 칼럼 순서의 중요성을 인지하지 못해 데이터 모델링 되어있는 상태로 DDL을 생성하여 성능이 저하되는 경우가 빈번

   1. 인덱스 중요성 : 데이터 조작 시 가장 효과적으로 처리될 수 있는 접근 경로 제공
      - 인덱스의 특징 : 여러개의 속성이 하나의 인덱스로 구성되어 있을 때, 앞쪽에 위치한 속성의 값이 비교자로 있어야 인덱스가 좋은 효율을 나타낼 수 있다. 앞쪽에 위치한 속성값이 가급적 '=' 아니면 최소한의 범위인 'BETWEEN'이 들어와야 한다.
   2. PK/FK 설계 중요성 : 데이터 접근 시 접근경로 제공, 설계단계 마지막에 칼럼 순서 조정
   3. PK 순서의 중요성 : 물리적 모델링 단계에서 스스로 생성된 PK 외에 상속되는 PK 순서도 중요
   4. FK 순서의 중요성 : 조인을 할 수 있는 수단이 됨 (=경로), 조회 조건 고려해서 반드시 인덱스 생성

5. PK 순서를 조정하지 않으면 성능 저하 되는 이유

   - 조회 조건(WHERE)에 따라 인덱스를 처리하는 범위가 달라짐
   - PK의 순서를 인덱스 특징에 맞게 생성하지 않고 자동으로 생성하면, 테이블에 접근하는 트랜잭션이 인덱스 범위를 넓게 하거나 풀 스캔(full scan)을 유발

6. 물리적 테이블에 FK 제약이 걸려있지 않은 경우 인덱스 미생성으로 생긴 성능 저하

   - 물리적으로 두 테이블 사이 FK 참조 무결성 관계를 걸어 상속받은 FK에 인덱스 생성

7. 인덱스 액세스 범위 좁히는 가장 좋은 방법

   - PK가 여러 개일 때, WHERE 절에 사용하는 조건용 칼럼들이 우선순위가 되어야 함
   - '=', EQUAL 조건, 동등 조건에 있는 칼럼이 제일 앞으로
   - BETWEEN, IN 범위 조건에 있는 칼럼이 그 다음 순위
   - 나머지 PK는 그 뒤에 아무렇게나



#### 6. 분산 데이터베이스와 성능

1. 분산 데이터베이스의 개념
   1. 물리적으로 분산된 데이터베이스를 하나의 논리적 시스템으로 사용
   2. 빠른 네트워크 환경을 이용하여 데이터베이스를 여러 지역에서 노드로 위치시켜 사용성과 성능을 극대화하는 데이터베이스
   3. 









































